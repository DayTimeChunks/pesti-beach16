---
title: "BEACH Formalisms"
header-includes: \usepackage{mathtools} \usepackage{natbib}
output:
  pdf_document:
    citation_package: natbib
    keep_tex: yes
  word_document: default
bibliography: library.bib
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Note: For word, replace string:
# ${[...comment..]:$.$ <- $.$}  # ignore dots.
# [comment]:$$

```

```{r include=FALSE}
# automatically create a bib database for R packages
# knitr::write_bib(c(.packages(), 'knitr', 'rmarkdown'), 'packages.bib' )
# knitr::write_bib(c(.packages(), 'knitr', 'rmarkdown'), 'packages.bib' )
```

# Methodology

## Hydrological Framework

### Lateral/subsurface flow

Later flow occurs when the soil moisture content exceeds the field capacity and is represented as the difference between inflow and outflow at a cell $j$ for each soil layer $z$ according to \cite{Manfreda2005}:

\begin{equation}
\Delta LF_{j(t)} = \Big( \frac{W_{j} \sum^{N(t)}_{i=1}max[c_{z}(SW_{i}-SW_{fc,i}),~0] }{ \sum^{N(t)}_{i=1} W_{i} } \Big) - max[c_z(SW_j-SW_{fc,j}),~0]
\label{eq:LF}  
\end{equation}

were $c_z$ is the subsurface flow coefficient ($\approx$ 0.25 $d^{-1}$, if $dt$ $\leq$ $1~d$), $SW$ and $SW_{fc}$ are the soil water content at time $t$ and at field capacity for the soil profile [mm], respectively. $N(t)$ is the number of cells $i$ upstream exceeding field capacity and at steepest slope to cell $j$. The topographical wetness index (TWI) $W$, introduced by \cite{Beven1979}, describes the tendency for water to accumulate spatially in regions characterized by a relatively low local slope and a large upstream drainage area. $W_j$ is the TWI at cell $j$ and $W_i$ the cumulative TWI from upstream cells $i$. The TWI is given by:    

\begin{equation}
TWI =ln\Big(\frac{a}{tan \beta} \Big)
\label{eq:Wz}  
\end{equation}

were $a$ is the drainage area per unit contour length (defined by the Local Drain Direction (LDD) network and cell area) and tan $\beta$, the local slope in radians derived from the Digital Elevation Model (DEM).


### Old Plant height


[comment]:$$
\begin{equation} 
    h = 
\begin{dcases}
     ~~~~~0~,                                     & t \leq t_{sow-date} \\
     \frac{~h_{max} \cdot~(t-t_{sow-date})}{\Delta t_{}} ,     & t \leq t_{sow-date} \\
    \frac{lnf}{-5\cdot10^{-5}},              & f > 0 
\end{dcases}
\end{equation}
[comment]:$$


### Soil Temperature

Temperture is an important parameter regulating chemical and biological processes. To simulate its evolution across time and space this model follows [@Neitsch2009], where the average daily soil temperature ($^{\circ}$C) at the center of each soil layer $z$ is given by:

\begin{equation}
T_{soil_z}(t) = l \cdot T_{soil_, k,_z}(t-1) + (1.0 - l) \cdot \big[df \cdot [\overline{T}_{AAir} - T_{ssurf}]+T_{ssurf}]
\label{eq:tempSoil} 
\end{equation}

where $l$ is a lag coefficient (0 - 1.0) regulating the influence of the previous day's $(t-1)$ temperature, $\overline{T}_{AAir}$ is the average annual air temperature and $T_{ssurf}$ is the soil surface temperature at time $t$. The depth factor $df$ is given by,

\begin{equation}
df = \frac{zd}{zd+exp(-0.867-2.078 \cdot zd)}
\label{eq:df} 
\end{equation}

where $zd$ is the ratio of the depth at the center of the soil layer $D_{z/2}$ (mm) to the damping depth $dd$ (mm) such that:
\begin{equation}
zd = \frac{D_{z/2}}{dd}
\label{eq:zd} 
\end{equation}

The damping depth $dd$ is a function of the maximum damping depth $dd_{max}$ (mm) and a soil water scaling factor $\varphi$ (-).

\begin{equation}
dd = dd_{max} \cdot exp \Big[ln\Big(\frac{500}{dd_{max}} \Big) \cdot \Big(\frac{1-\varphi}{1+\varphi}\Big)^2\Big]
\label{eq:dd} 
\end{equation}

\begin{equation} 
dd_{max} = 1000 + \frac{2500\rho_b}{\rho_b+686 \cdot exp(-5.63\rho_b)}
\label{eq:ddmax} 
\end{equation}

\begin{equation} 
\varphi = \frac{SW}{(0.356-0.144\rho_b) \cdot D_{k}}
\label{eq:varphi} 
\end{equation}

where $\rho_b$ is the soil bulk density $(mg~m^{-3})$ and SW is water content $(mm~H_2O)$ in the soil profile $D_z~(mm)$. 

The soil surface temperature $T_{ssurf}$ in eq. \ref{eq:tempSoil}, is a fucntion of the previous day's soil temperature, amount of ground cover captured by a crop factor $bcv$ and the temperature of bare soil $T_{bare}$, such that:

\begin{equation} 
T_{ssurf} = bcv \cdot  T_{soil, k, t-1} + (1-bcv) \cdot T_{bare}
\label{eq:Tssurf} 
\end{equation}

\begin{equation} 
bcv = \frac{CV}{(CV+exp(7.563-1.297 \cdot 10^{-4} \cdot CV))}
\label{eq:Tssurf} 
\end{equation}

[comment]:$$
\begin{equation} 
    CV = 
\begin{dcases}
     ~~~~~0~,                                     & f \leq 0 \\
    \frac{lnf}{-5\cdot10^{-5}},              & f > 0 
\end{dcases}
\end{equation}
[comment]:$$


\begin{equation} 
f=1-exp(-\mu*LAI)
\label{eq:f} 
\end{equation}

where $\mu$ is light-use efficiency of the crop $(kg~ha^{-1}~m^2~MJ^{-1})$.

## Pesticide transport 

Aqueous concentration is obtained with the following function. Note that the input parameter, `mass`, may be equal to the total concentration or either the heavy or light fractions, whichever output is required by the user.


```{python}

def getConcAq(model, layer, theta_sat, mass,
              sorption_model="linear", gas=True):
    # Note that p_b (g/cm3) x k_d (L/Kg) -> unit-less
    if layer == 0:
        depth = model.z0
        theta_layer = model.theta_z0
    elif layer == 1:
        depth = model.z1
        theta_layer = model.theta_z1
    elif layer == 2:
        depth = model.z2
        theta_layer = model.theta_z2

    if sorption_model == "linear":
        # Retardation factor
        retard_layer = 1 + (model.p_b * model.k_d) / theta_layer
    else:
        print("No sorption assumed, Ret. factor = 1")
        retard_layer = 1  # No retardation.

    if gas:  # Leistra et al., 2001
        theta_gas = max(theta_sat - theta_layer, scalar(0))
        conc_aq = mass / ((cellarea() * depth) *  # m2 * mm = L
                          (theta_gas / model.k_h +
                           theta_layer * retard_layer))  # ug/L cell volume
    else:  # No gas phase
        # Whelan, 1987
        conc_aq = (mass / (cellarea() * depth * theta_layer * retard_layer)) 

    return conc_aq

```


### Volatilization

To obtain the pesticide mass volatilized at each time step, the following function is defined:

```{python}
def getVolatileMass(model, temp_air, theta_sat, mass, frac,
                    rel_diff_model="option-1", sorption_model="linear",
                    gas=True, isotopes=True, ):
    # Volatilize only during peak volatilization time i.e., first 24 hrs, @Prueger2005.
    theta_layer = model.theta_z0
    theta_gas = max(theta_sat - theta_layer, scalar(0))
    # Convert to m (needed for final mass computation on cell basis)
    depth_m = model.z0 * 1 / 10 ** 3
    # Air boundary layer, assumed as 2m high
    thickness_a = scalar(1.0)  # m
    # Diffusion coefficient in air (cm^2/s); https://www.gsi-net.com
    #  D_ar (metolachlor) = 0.03609052694,  at reference Temp., in Kelvin, D_a,r)
    diff_ar = 0.03609052694 * 86400.0 * 1.0 / 10 ** 4  # m2/d
    # Diffusion coefficient adjusted to air Temp. in Kelvin, D_a
    diff_a = ((temp_air + 273.15) / 293.15) ** 1.75 * diff_ar  # m2/d

    if rel_diff_model == "option-1":
        # Millington and Quirk, 1960 (in Leistra, 2001, p.48)
        # a,b parameters: Jin and Jury, 1996 (in Leistra, 2001)
        diff_relative_gas = (diff_a * theta_gas ** 2 /
                             theta_sat ** (2 / 3))  # m2/d
    elif rel_diff_model == "option-2":
        # Currie 1960 (in Leistra, 2001)
        # a,b parameters: Baker, 1987 (in Leistra, 2001)
        diff_relative_gas = diff_a * 2.5 * theta_gas ** 3  # m2/d
    else:
        print("No appropriate relative diffusion parameter chosen")
        diff_relative_gas = diff_a  # m2/d
    # Transport resistance through air (r_a) and soil (r_s) layer
    r_a = thickness_a / diff_a  # d/m
    r_s = (0.5 * depth_m) / diff_relative_gas  # d/m

    conc_aq = getConcAq(model, 0, theta_sat, mass,
                        sorption_model=sorption_model, gas=gas, isotopes=isotopes)
    # Convert ug/L to ug/m3, as will be multiplying by cell's area in m2
    conc_aq *= 10 ** 3  # ug/L * 10^3 L/m3
    conc_gas = conc_aq / model.k_h  # ug/L air
    volat_flux = (conc_gas / (r_a + r_s)) * cellarea()  # ug/day
    return volat_flux
```


### Run-off Loss

To obtain the mass lost to run-off the following function is defined:

```{python}
def getRunOffMass(model, theta_sat, precip, runoff_mm,
                  mass, frac,
                  transfer_model="simple-mt", sorption_model="linear",
                  gas=True, isotopes=True):
    # Aqueous concentration
    conc_aq = getConcAq(model, 0, theta_sat, mass,
                        sorption_model=sorption_model, gas=gas, isotopes=isotopes)

    if transfer_model == "simple-mt":
        mass_ro = conc_aq * runoff_mm * cellarea()
    elif transfer_model == "nu-mlm-ro":
        # non-uniform-mixing-layer-model-runoff (nu-mlm-ro)
        # Considers a decrease in effective transfer as mixing layer depth increases
        # Adapted from Ahuja and Lehman, 1983 in @Shi2011,
        # Adaptation replaces Precip by Runoff amount.
        b = 1  # [mm] Calibration constant, 1 >= b > 0 (b-ranges appear reasonable).
        # As b decreases, mass transfer increases, model.z0 in mm
        mass_ro = (runoff_mm * cellarea()) * exp(-b * model.z0) * conc_aq 
    elif transfer_model == "nu-mlm":
        # non-uniform-mixing-layer-model (nu-mlm)
        # Original from Ahuja and Lehman, 1983 in @Shi2011
        b = 1  # [mm] Calibration constant, 1 >= b > 0 (b-ranges appear reasonable).
        # As b decreases, mass transfer increases, model.z0 in mm
        mass_ro = (precip * cellarea()) * exp(-b * model.z0) * conc_aq
    elif transfer_model == "d-mlm":
        # distributed mixing-layer-model (d-mlm)
        # Adapted from Havis et al., 1992, and
        # taking the K_L definition for laminar flow from Bennett and Myers, 1982.
        mass_ro = getKfilm(model, runoff_mm) * cellarea() * conc_aq  
    else:
        print("Run-off transfer model not stated")
        return None

    return mass_ro
```

To obtain $K_L$ the following function is defined and implemented when `transfer_model = 'd-mlm'` is declared in `getRunOffMass()` above:   

```{python}
def getKfilm(model, runoffvelocity):
    """
    Note: Model uses run-off (mm) per day (i.e. timestep) as runoff velocity.
    Chemical parameter source:
    http://www.gsi-net.com/en/publications/gsi-chemical-database/single/377.html
    """
    # Dynamic viscosity of water (\mu) @25 Celsius = 8.9e-04 [Pa s]
    #   1 Pa = 1 N/(m s^2) = 1 Kg/(m s^2)
    #   Convert to g/(cm s): dyn_visc = 8.9e-03 [g/cm s]
    dyn_visc = 8.9e-03  # [g/cm s] @25 degrees, [@Shi2011]:\mu

    # Solute diffusivity in water (D_w)
    # Metolachlor = 5.0967719112e-006 (cm2 / s)
    diff_solute = 5.0967719112e-006  # [cm2 / s], [@Shi2011]:D_w
    Sc = dyn_visc / (model.p_b * diff_solute)  # (-) Schmidt number, [@Shi2011]:S_c

    # Reynolds number (dimensionless), 86400s = 1 day
    cell_length = 2 * 10 ** 3  # mm
    # Reynolds (Re), [-] (Shi et al., 2011)
    re = (model.p_b * 1 / 10 ** 2 * runoffvelocity * cell_length) / (dyn_visc * 86400)
    kl = (0.664 * ((diff_solute * 86400 * 10 ** 2) / cell_length) *
          re ** (float(1) / 2) * Sc ** (float(1) / 3)) 
    return kl  # mm/day
```


### Leachate mass

```{python}
def getLeachedMass(model, layer, theta_sat,
                   water_flux,
                   theta_after_percolate,
                   mass,
                   sorption_model=None,
                   leach_model=None, gas=True, isotopes=True):
    if layer == 0:
        depth = model.z0
        theta_layer = model.theta_z0
    elif layer == 1:
        depth = model.z1
        theta_layer = model.theta_z1
    elif layer == 2:
        depth = model.z2
        theta_layer = model.theta_z2

    # Aqueous concentration
    conc_aq = getConcAq(model, layer, theta_sat, mass,
                        sorption_model=sorption_model, gas=gas, isotopes=isotopes)

    if sorption_model == "linear":
        # Retardation factor
        retard_layer = scalar(1) + (model.p_b * model.k_d) / theta_layer
    else:
        print("No sorption assumed, Ret. factor = 1")
        retard_layer = scalar(1)  # No retardation.

    if leach_model == "mcgrath":
        if layer == 0:
            conc_aq_new = conc_aq * exp(-water_flux / (theta_layer * retard_layer * depth))
            mass_aq = conc_aq * (theta_layer * depth * cellarea())
            mass_aq_new = conc_aq_new * (theta_after_percolate * depth * cellarea())
            mass_leached = mass_aq - mass_aq_new
            if mapminimum(mass_aq_new) < 0:
                print("Error in Leached Model")
        else:
            # McGrath not used in lower layers,
            # as formulation accounts for rainfall impact
            mass_leached = conc_aq * water_flux * cellarea()
            mass_aq = conc_aq * (theta_layer * depth * cellarea())
            mass_aq_new = mass_aq - mass_leached
            if mapminimum(mass_aq_new) < 0:
                print("Error in Leached Model")
    else:
        mass_leached = conc_aq * water_flux * cellarea()
        mass_aq = conc_aq * (theta_layer * depth) * cellarea()
        mass_aq_new = mass_aq - mass_leached
        if mapminimum(mass_aq_new) < 0:
            print("Error in Leached Model")

    return mass_leached
```


### Lateral mass flux (OLD - Manfreda)

Later mass flux is proportional to the aqueous concentration in lateral water flow. It is obtained by adapting eq. \ref{eq:LF}, where the difference between mass loss in upstream cells $i$ and mass loss at cell $j$ is:

\begin{equation}
\Delta LMF_{j,z} = \sum^{N(t)}_{i=1} M_{loss, i(t)} - M_{loss,j(t)}
\label{eq:LMF}  
\end{equation}

The mass gain at cell $j$ is given by the mass loss from upstream cells $i$ contributing to downstream cells and given by:

\begin{equation}
\sum^{N(t)}_{i=1} M_{loss, i(t)} = \frac{W_{j} \sum^{N(t)}_{i=1}max[ C_{i,aq}\cdot\Big(c_{z}(SW_{i}-SW_{fc,i})\Big),~0] }{ \sum^{N(t)}_{i=1} W_{i} }
\label{eq:LFMgain} 
\end{equation}
Loss at cell $j$ is then given by:

\begin{equation}
M_{loss,j(t)} = C_{j,aq}\cdot\Big(c_{z}(SW_{j}-SW_{fc,j})\Big)
\end{equation}
 
Simplfying for the relative wetness index at cell $j$ in eq. \ref{eq:LFMgain}, we obtain:

\begin{equation}
W_{j/i} = \frac{W_{j}}{\sum^{N(t)}_{i=1} W_{i} } 
\end{equation}

```{python}
def getLatMassFlux(model, layer, theta_sat, theta_fcap,
                   mass, sorption_model='linear', gas=True, isotopes=True):
    if layer == 0:
        depth = model.z0
        theta_layer = model.theta_z0
        c = model.c1
    elif layer == 1:
        depth = model.z1
        theta_layer = model.theta_z1
        c = model.c1
    elif layer == 2:
        depth = model.z2
        theta_layer = model.theta_z2
        c = model.c2

    # Aqueous concentration
    conc_aq = getConcAq(model, layer, theta_sat, mass,
                        sorption_model=sorption_model, gas=gas, isotopes=isotopes)

    # W(j/i)
    rel_wetness = model.wetness / accuflux(model.ldd_subs, model.wetness)

    # Cell mass loss/gain (to update only mass)
    mass_loss = max(conc_aq * (c * (depth * theta_layer - depth * theta_fcap)), scalar(0))
    mass_gain = rel_wetness * accuflux(model.ldd_subs, mass_loss)
    net_mass_latflux = mass_gain - mass_loss

    return {
        'mass_loss': mass_loss,
        'mass_gain': mass_gain,
        'net_mass_latflux': net_mass_latflux
    }
```


## Degradation


```{r include=FALSE}
# Note: Only first 24 hrs or first 5 mm cummulative rainfall?
```


### Biodegradation  (OLD - differences kept here)

Although a decrease in degradation rates with increasing depth reltive to top soils may be associated to a decrease in microbial activity **(RodrÃ­guez-Cruz et al., 2006; Si et al., 2009)**, currently no depth variation is considered. However, this could be easily implemented by assuming an exponential decrease in the degradation rate constant as a function of depth such that: 

\begin{equation}
k_{{b,aq}_z} = k_{b,aq}\cdot exp(-\gamma \cdot D_{z/2}) 
\label{eq:gamma}
\end{equation} 

where $\gamma$ $(-)$ is a calibration parameter $0 \leq \gamma \leq 1$ and $D_{z/2}~(m)$ the depth to center of layer $z$. 

To compute  mass degradation, the following method is used:

```{python}
def getMassDegradation(model, layer,
                       theta_sat, theta_fcap, theta_wp,
                       mass, frac="L", sor_deg_factor=1,
                       sorption_model="linear", gas=True):
    # Get mass applied if top-soil
    if layer == 0:
        theta_aq_layer = model.theta_z0
        temp_layer = model.temp_z0_fin
        depth = model.z0
    elif layer == 1:
        theta_aq_layer = model.theta_z1
        temp_layer = model.temp_z1_fin
        depth = model.z1
    elif layer == 2:
        theta_aq_layer = model.theta_z2
        temp_layer = model.temp_z2_fin
        depth = model.z2

    # F_Theta_1
    theta_factor = ifthenelse(
        theta_aq_layer <= 0.5 * theta_wp, scalar(0),
        ifthenelse(theta_aq_layer <= theta_fcap,
                   (((theta_aq_layer - 0.5 * theta_wp) / (
                       theta_fcap - theta_wp)) ** scalar(model.beta_moisture)),
                   scalar(1)))
    # Temperature factor in biodegradation
    # F_T_1
    temp_factor = exp((model.act_e / model.r_gas) *
                      (1 / (model.temp_ref + 273.15) - 1 / (model.temp_air + 273.15)))

    # Half-life as a function of temperature and moisture
    dt_50 = max(model.dt_50_ref * theta_factor * temp_factor, scalar(0))
    # dt_50 = max(model.dt_50_ref)

    # Convert to degradation constant
    # Deg in dissolved phase
    k_b = ifthenelse(dt_50 > 0, ln(2) / dt_50,
                     scalar(0))  
    # Deg in sorbed phase (now assumed equal)
    k_bs = k_b * sor_deg_factor

    # Step 0 - Obtain species concentration (all phases)
    conc_aq = getConcAq(model, layer, theta_sat, mass,
                        sorption_model=sorption_model, gas=gas)  # mass/L
    conc_ads = getConcAds(model, layer, theta_sat, mass, gas=gas)  # mass/g soil
    conc_gas = conc_aq / model.k_h

    mass_aq = conc_aq * (theta_aq_layer * depth * cellarea())
    mass_ads = conc_ads * (depth * cellarea() * model.p_b)  # pb = g/cm3

    # Step 1 - Degrade phase fractions
    # First order degradation kinetics
    theta_gas = max(theta_sat - theta_aq_layer, scalar(0))
    if frac == "H":
        conc_aq_new = conc_aq * exp(-1 * model.alpha_iso * k_b * scalar(model.jd_dt))
        conc_ads_new = conc_ads * exp(-1 * model.alpha_iso * k_bs * scalar(model.jd_dt))
    else:  # Same for total conc as for "L"
        conc_aq_new = conc_aq * exp(-1 * k_b * scalar(model.jd_dt))
        conc_ads_new = conc_ads * exp(-1 * k_bs * scalar(model.jd_dt))

    # Step 2 - Convert to mass (i.e., after degradation in each phase)
    mass_aq_new = conc_aq_new * (theta_aq_layer * depth * cellarea())
    mass_ads_new = conc_ads_new * (model.p_b * depth * cellarea())  # pb = g/cm3
    mass_gas = conc_gas * (theta_gas * depth * cellarea())
    mass_tot_new = mass_aq_new + mass_ads_new + mass_gas
    mass_deg_aq = mass_aq - mass_aq_new
    mass_deg_ads = mass_ads - mass_ads_new

    return {"mass_tot_new": mass_tot_new,
            "mass_deg_aq": mass_deg_aq,
            "mass_deg_ads": mass_deg_ads}
```


### Isotope treatment

To obtain the masses of heavy $M^h$ and light isotopes $M^l$, the isotope signature $\delta ^{13}C$ is used where:

\begin{equation} 
\delta ^{13}C [\textperthousand] = \Big(\frac{R_{smp} - R_{std}}{R_{std}}\Big)\cdot 1000
\end{equation}


\begin{equation} 
R_{smp} = \frac{M^h}{M^l} 
\end{equation} 

\begin{equation} 
R_{std} = 11237.2 \cdot 10^{-6}
\end{equation}


and where the total mass $M_{tot} = M^h + M^l$, we obtain:

\begin{equation} 
R_{std}\Big(\delta ^{13}C/1000+1 \Big)= \frac{M_{tot}-M^l}{M^l}
\end{equation}

\begin{equation} 
M^l = \frac{M_{tot}}{1+R_{std}(\delta ^{13}C/1000+1)}
\end{equation}


\begin{equation} 
M^h = M_{tot} - M^l 
\end{equation}


#```{r test-child, child = 'Bioavailability.Rmd'}
#```



# References 

