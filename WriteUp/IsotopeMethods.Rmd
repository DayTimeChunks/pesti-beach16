---
title: "Isotope Tracking"
header-includes: \usepackage{mathtools} \usepackage{natbib}
output:
  pdf_document:
    citation_package: natbib
    keep_tex: yes
  word_document: default
bibliography: library.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Note: For word, replace string:
# ${[...comment..]:$.$ <- $.$}  # ignore dots.
# [comment]:$$
```

```{r include=FALSE}
# automatically create a bib database for R packages
knitr::write_bib(c(.packages(), 'knitr', 'rmarkdown'), 'packages.bib' )
```


## Applications

After a new product application at time $t+1$, the top soil carbon isotope signature ($\delta ^{13}C$) for a soil layer $k$, is updated by balancing mass terms. Note that for pesticide applications only the first layer ($k=z0$) is considered, such that:

$$
\delta ^{13}C_{k(t+1)} = \frac{1}{M_{k,tot(t+1)}} \Big(\delta ^{13}C_{k(t)} \cdot M_{k(t)} + \delta ^{13}C_{app(t+1)} \cdot M_{app(t+1)}  \Big)
$$

$$
M_{k,tot(t+1)} =  M_{k(t)} + M_{app(t+1)}
$$
where $M_{k(t)}$ is the pesticide mass $(\mu g)$ for the layer $k$ present before application $app$. 

## Non-reactive transport

For each non-fractionating mass transfer process $\delta ^{13}C$ is updated also by balancing mass terms for each cell:   

$$
\delta ^{13}C_{k(t+1)} = \frac{1}{M_{k,tot(t+1)}} \Big(\delta ^{13}C_{k(t)} \cdot M_{k(t)} + \delta ^{13}C_{gain(t+1)} \cdot M_{gain(t+1)} -  \delta ^{13}C_{loss(t+1)} \cdot M_{loss(t+1)}  \Big)
$$

$$
M_{k,tot(t+1)} =  M_{k(t)} + M_{gain(t+1)} -  M_{loss(t+1)}
$$


Update at each cell for each layer is computed by the follwing function, where the relevant layer and processes is selected:


```{python}

def update_layer_delta(model, layer, process, mass_process, mass_before_transport):
    if layer == 0:
      delta_layer = model.delta_z0
      delta_layer_above = None
      mass_layer = model.pestmass_z0
    elif layer == 1:
        delta_layer = model.delta_z1
        delta_layer_above = model.delta_z0
        mass_layer = model.pestmass_z1
    elif layer == 2:
        delta_layer = model.delta_z2
        delta_layer_above = model.delta_z1
        mass_layer = model.pestmass_z2
        
    if process == "volat":
        pass
    elif process == "runoff":
        pass
    elif process == "leach":
        pass
    else:
        raise NotImplementedError
    
    return "updated delta for delta_layer"
                       
```

For brevity, only two examples are shown. For volatilization, the process process=**"volat"** is chosen and the updated $\delta ^{13}C$ for a soil layer $k$ is returned as,

```{python}

def update_layer_delta(model, layer, process, mass_process, mass_before_transport):
    if layer == 0:
      delta_layer = model.delta_z0
      delta_layer_above = 0
      mass_layer = model.pestmass_z0
    elif layer == 1:
        delta_layer = model.delta_z1
        delta_layer_above = model.delta_z0
        mass_layer = model.pestmass_z1
    elif layer == 2:
        delta_layer = model.delta_z2
        delta_layer_above = model.delta_z1
        mass_layer = model.pestmass_z2
        
    if process == "volat":
        mass_loss = mass_process["mass_loss"]
        mass_gain = 0
        delta_gain = 0
        delta_loss = delta_layer
        
    elif process == "runoff":
        pass
    elif process == "leach":
        pass
    else:
        raise NotImplementedError

    mass_tot = mass_before_transport + mass_gain - mass_loss
    delta_int = ((1/mass_tot) *
                 (delta_layer * mass_before_transport +  # initial
                  delta_gain * mass_gain -  # mass_in
                  delta_loss * mass_loss))  # mass_out
                  
    return delta_int
                       
```

For lateral flux, update follows the same approach as that for water mass exchange across cells. The pesticide mass at cell $j$ after lateral flux is given by:

$$
M_{j, tot(t+1)} = M_{j(t)} + \sum^{N(t)}_{i=1} M_{loss, i(t)} - M_{loss,j(t)} 
$$

The mass gain at cell $j$ is given by the mass from upstream cells $i$ contributing to downstream cells and given by:

$$
\sum^{N(t)}_{i=1} M_{loss, i(t)} = \frac{W_{j} \sum^{N(t)}_{i=1}max[ C_{i,aq}\cdot\Big(c_{z}(SW_{i}-SW_{fc,i})\Big),~0] }{ \sum^{N(t)}_{i=1} W_{i} }
$$
Loss at cell $j$ is then given by:

$$
M_{loss,j(t)} = C_{j,aq}\cdot\Big(c_{z}(SW_{j}-SW_{fc,j})\Big)
$$
Considering the isotope mass balance, while simplfying for the relative wetness index at cell $j$, we obtain:

$$
W_{j/i} = \frac{W_{j}}{\sum^{N(t)}_{i=1} W_{i} } 
$$

$$
\delta ^{13}C_{j(t+1)} = \frac{1}{M_{j,tot(t+1)}} 
\Big(\delta ^{13}C_{j,(t)} \cdot M_{j(t)} + 
W_{j/i} \sum^{N(t)}_{i=1}max[ \delta ^{13}C_{i} \cdot C_{i,aq}\cdot\Big(c_{z}(SW_{i}-SW_{fc,i})\Big),~0] - 
\delta ^{13}C_{j(t)} \cdot M_{loss,j(t)}  \Big)
$$

The *getLatMassDeltaFlux* implements the above equation for lateral mass flux as:

```{python}

def getLatMassDeltaFlux(model, layer, theta_sat, theta_fcap,
                        mass_before_transport, sorption_model='linear', gas=True):
    if layer == 0:
        depth = model.z0
        delta_layer = model.delta_z0
        theta_layer = model.theta_z0
        mass_layer = model.pestmass_z0
        c = model.c1
    elif layer == 1:
        depth = model.z1
        delta_layer = model.delta_z1
        theta_layer = model.theta_z1
        mass_layer = model.pestmass_z1
        c = model.c1
    elif layer == 2:
        store = False
        depth = model.z2
        delta_layer = model.delta_z2
        theta_layer = model.theta_z2
        mass_layer = model.pestmass_z2
        c = model.c2

    if sorption_model == "linear":
        # Retardation factor
        retard_layer = 1 + (model.p_b * model.k_d) / theta_layer
    else:
        retard_layer = 1

    if gas:
        # Leistra et al., 2001
        theta_gas = theta_sat - theta_layer
        conc_layer_aq = mass_layer / ((cellarea() * depth) *
                                      (theta_gas * model.k_h + theta_layer * retard_layer))  # mg/L
    else:
        # Whelan, 1987 # No gas phase considered
        conc_layer_aq = (mass_layer / cellarea()) / (theta_layer * retard_layer * depth)  # mg/L

    # W(j/i)
    rel_wetness = model.wetness / accuflux(model.ldd_subs, model.wetness)

    # Cell mass loss/gain (to update only mass)
    mass_loss = max(conc_layer_aq * (c * (depth * theta_layer - depth * theta_fcap)), scalar(0))
    mass_gain = rel_wetness * accuflux(model.ldd_subs, mass_loss)
    net_mass_latflux = mass_gain - mass_loss

    # massDelta  loss/gain (to update only delta)
    massdC_loss = max(delta_layer * conc_layer_aq * (c * (depth * theta_layer - depth * theta_fcap)), scalar(0))
    massdC_gain = rel_wetness * accuflux(model.ldd_subs, massdC_loss)

    # Isotope mass balance update three terms:
    mass_tot = mass_before_transport + mass_gain - mass_loss
    # 1st fraction term (f1), must: f1 > 1, with net gain
    f1 = (mass_before_transport / mass_tot) * delta_layer
    f2 = massdC_gain / mass_tot
    f3 = massdC_loss / mass_tot
    delta_layer = f1 + f2 - f3

    return {
        'mass_loss': mass_loss,  # mg
        'mass_gain': mass_gain,  # mg
        'net_mass_latflux': net_mass_latflux,  # mg
        'massdC_loss': massdC_loss,  # mg*dC
        'massdC_gain': massdC_gain,  # mg*dC
        'f1': f1,  # could be > 1  (if net gain)
        'f2': f2,
        'f3': f3,
        'delta_layer': delta_layer
    }
                       
```

# Converting $\delta ^{13}C_{i}$ to individual species

$$
\delta ^{13}C_{i} = \frac{R_s - R_{std}}{R_{std}}
$$
